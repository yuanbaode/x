package project

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
)

type Project struct {
	baseDir string
	name    string
}

func NewProject(name string) *Project {
	baseDir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	return &Project{
		name:    name,
		baseDir: baseDir,
	}
}

func (receiver *Project) CreateProject() (err error) {
	projectDir := receiver.baseDir + string(os.PathSeparator) + receiver.name
	err = os.MkdirAll(projectDir, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
	bllDir := projectDir + string(os.PathSeparator) + "bll"

	implDir := bllDir + string(os.PathSeparator) + "impl"
	err = os.MkdirAll(implDir, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}

	modelDir := projectDir + string(os.PathSeparator) + "model"
	poDir := modelDir + string(os.PathSeparator) + "po"
	err = os.MkdirAll(poDir, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
	dtoDir := modelDir + string(os.PathSeparator) + "dto"
	err = os.MkdirAll(dtoDir, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
	daoDir := projectDir + string(os.PathSeparator) + "dao"
	err = os.MkdirAll(daoDir, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}

	bllFilePath := bllDir + string(os.PathSeparator) + "bll.go"
	bllFile, err := os.Create(bllFilePath)
	if err != nil {
		log.Fatal(err)
	}
	bllFile.WriteString(fmt.Sprintf(goFile, "bll"))
	bllFile.Close()

	implFilePath := implDir + string(os.PathSeparator) + "impl.go"
	implFile, err := os.Create(implFilePath)
	if err != nil {
		log.Fatal(err)
	}
	implFile.WriteString(fmt.Sprintf(goFile, "impl"))
	implFile.Close()

	log.Println("init project success")
	return
}

const goFile = `// Code generated by log-gen. DO NOT EDIT.
package %s`

func ast2() {
	p := &ast.File{
		Doc:        nil,
		Package:    1,
		Name:       ast.NewIdent("main"),
		Decls:      nil,
		Scope:      nil,
		Imports:    nil,
		Unresolved: nil,
		Comments:   nil,
	}
	_ = p
}

func ast1() {

	src := `package main

import (
    "fmt"
)

func main() {
    fmt.Printf("Hello, Golang\n")
}`
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", src, 0)
	if err != nil {
		fmt.Printf("err = %s", err)
	}
	//ast.Print(fset, f)

	file, err := os.Create("demo.go")
	if err != nil {
		log.Fatal(err)
	}

	writeGoFile(file, f.Decls)

}
func astToGo(dst *bytes.Buffer, node interface{}) error {
	addNewline := func() {
		err := dst.WriteByte('\n') // add newline
		if err != nil {
			log.Panicln(err)
		}
	}

	addNewline()

	err := format.Node(os.Stdout, token.NewFileSet(), node)
	if err != nil {
		return err
	}

	addNewline()

	return nil
}
func writeGoFile(wr io.Writer, funcs []ast.Decl) error {
	// 输出Go代码
	header := `// Code generated by log-gen. DO NOT EDIT.
package log
`
	buffer := bytes.NewBufferString(header)

	for _, fn := range funcs {
		err := astToGo(buffer, fn)
		if err != nil {
			return errors.New("astToGo err")
		}
	}

	_, err := wr.Write(buffer.Bytes())
	return err
}
